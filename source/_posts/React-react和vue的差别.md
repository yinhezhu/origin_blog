---
title: React_react和vue的差别
date: 2018-04-17 16:32:25
tags: [React,不同技术栈]
category: "React"
---
# Vue与React的对比
`Vue.js`与`React.js`从某些反面来说很相似，通过两个框架的学习，有时候对一些用法会有一点思考，为加深学习的思索，特翻阅了两个文档，从以下各方面进行了对比，加深了对这两个框架的认知。

## 1.数据绑定

### 1.1 Vue中有关数据绑定的部分
- vue是双向绑定， `Vue.js` 最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。所谓双向绑定，指的是`Vue`实例中的data与其渲染的DOM元素的内容保持一致，无论谁被改变，另一方会相应的更新为相同的数据。这是通过设置属性访问器实现的。
- 在`Vue`中，与数据绑定有关的有 `插值表达式、指令系统、*Class和Style、事件处理器和表单空间、ajax请求和计算属性`

#### 1.1.1插值表达式
插值和指令又称为模板语法
- 数据绑定最常见的形式就是使用`“Mustache”`语法 (双大括号) 的文本插值
- `Mustache` 语法不能作用在 ``HTML`` 特性上，遇到这种情况应该使用 `v-bind` 指令

#### 1.1.2 指令
- `Vue`中的指令很方便，指令 (Directives) 是带有 `v-` 前缀的特殊属性。指令属性的值预期是单个 `JavaScript` 表达式 (`v-for` 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 `DOM`。

- `Vue`中的12个指令： `v-bind,v-once,v-model,v-text,v-html,v-on,v-if,v-else,v-show,v-for,v-pre,v-clock`

#### 1.1.3 class与style绑定
- 数据绑定的一个常见需求是操作元素的 `class 列表和它的内联样式。因为它们都是属性 ，我们可以用`v-bind` 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 `v-bind` 用于 `class` 和 `style` 时，`Vue.js` 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。
- 对象语法
    - 我们可以传给 `v-bind:class` 一个对象，以动态地切换 `class`
- 数组语法
    - 我们可以把一个数组传给 `v-bind:class`，以应用一个 `class` 列表：

```javascript
<div v-bind:class="[activeClass, errorClass]"></div>
```

#### 1.1.4 条件渲染和列表渲染
- `v-if`条件渲染一组数
- 我们用 `v-for` 指令根据一组数组的选项列表进行渲染。`v-for` 指令需要使用 `item in items` 形式的特殊语法，`items` 是源数据数组并且 `item` 是数组元素迭代的别名。

#### 1.1.5 事件处理器
- 通过`v-on`给元素注册事件
- 使用 `v-on` 有几个好处：
    - 扫一眼 ``HTML`` 模板便能轻松定位在 `JavaScript` 代码里对应的方法。
    - 因为你无须在 `JavaScript` 里手动绑定事件，你的 `ViewModel` 代码可以是非常纯粹的逻辑，和 `DOM` 完全解耦，更易于测试。
    - 当一个 `ViewModel` 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。

#### 1.1.6 表单控件
- `v-model`在表单控件元素上创建双向数据绑定
- 它会根据控件类型自动选取正确的方法来更新元素。

#### 1.1.7 计算属性
- 在`Vue`中引入了计算属性来处理模板中放入太多的逻辑会让模板过重且难以维护的问题，这样不但解决了上面的问题，而且也同时让模板和业务逻辑更好的分离。
- 简单来说，假如`data`里面有属性`a=1`，然后你需要一个变量跟着`a`变化，例如`b=a+1`，那么就需要用到计算属性，`Vue`实例的`computed`属性中，设置`b`为其属性，其表现为一个函数，返回值是`b`的值。

#### 1.1.8 ajax数据请求
- `vue2.0`中数据请求推荐使用`axios`

注： `关于vue的数据双向绑定和单向数据流`
- `Vue` 的依赖追踪是【原理上不支持双向绑定，`v-model` 只是通过监听 `DOM` 事件实现的语法糖】

- `Vue`的依赖追踪是通过 `Object.defineProperty` 把`data`对象的属性全部转为 `getter/setter`来实现的；当改变数据的某个属性值时，会触发`set`函数,获取该属性值的时候会触发`get`函数，通过这个特性来实现改变数据时改变视图；也就是说只有当数据改变时才会触发视图的改变，反过来在操作视图时，只能通过DOM事件来改变数据，再由此来改变视图，以此来实现双向绑定

- 双向绑定是在同一个组件内，将数据和视图绑定起来，和父子组件之间的通信并无什么关联；
- 组件之间的通信采用单向数据流是为了组件间更好的解耦，在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以`vue`不推荐子组件修改父组件的数据，直接修改`props`会抛出警告

### 1.2 `react`没有数据双向绑定
- `react`是单向数据流
- `react`中通过将`state`（Model层）与`View`层数据进行双向绑定达数据的实时更新变化，具体来说就是在`View`层直接写`JS`代码`Model`层中的数据拿过来渲染，一旦像表单操作、触发事件、`ajax`请求等触发数据变化，则进行双同步

#### 1.2.1事件处理
- `React` 元素的事件处理和 `DOM`元素的很相似。但是有一点语法上的不同:

    - `React`事件绑定属性的命名采用驼峰式写法，而不是小写。
    - 如果采用 `JSX` 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(`DOM`元素的写法)
    - 在 `React` 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。
    - 当你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。一般需要显式的绑定`this`，例如

    `this.handleClick = this.handleClick.bind(this);`

    - 你必须谨慎对待 `JSX` 回调函数中的 `this`，类的方法默认是不会绑定 `this` 的。如果你忘记绑定 `this.handleClick` 并把它传入 `onClick`, 当你调用这个函数的时候 `this` 的值会是 `undefined`。

#### 1.2.2 条件渲染
- `React` 中的条件渲染和 `JavaScript` 中的一致，使用 `JavaScript` 操作符 `if` 或条件运算符来创建表示当前状态的元素，然后让 `React` 根据它们来更新 UI。
- 你可以通过用花括号包裹代码在 ``JSX`` 中嵌入任何表达式 ，也包括 `JavaScript` 的逻辑与 &&，它可以方便地条件渲染一个元素。之所以能这样做，是因为在 `JavaScript` 中，`true && expression` 总是返回 `expression`，而 `false && expression` 总是返回 `false`。因此，如果条件是 `true`，&& 右侧的元素就会被渲染，如果是 `false`，`React` 会忽略并跳过它。
- 条件渲染的另一种方法是使用 `JavaScript` 的条件运算符 `condition ? true : false`。

#### 1.2.3 列表渲染
- 你可以通过使用{}在`JSX`内构建一个元素集合，使用`Javascript`中的`map()`方法循遍历数组
- Keys可以在`DOM`中的某些元素被增加或删除的时候帮助`React`识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key。

#### 1.2.4 表单操作
- `HTML`表单元素与`React`中的其他`DOM`元素有所不同,因为表单元素生来就保留一些内部状态。
- 当用户提交表单时，`HTML`的默认行为会使这个表单会跳转到一个新页面。在`React`中亦是如此。但大多数情况下，我们都会构造一个处理提交表单并可访问用户输入表单数据的函数。实现这一点的标准方法是使用一种称为“受控组件”的技术。其值由`React`控制的输入表单元素称为“受控组件”。`this.setState({value: event.target.value})`;
- 当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 `event.target.name`的值来选择做什么。

#### 1.2.5 状态提升
- 在`React`中，状态分享是通过将`state`数据提升至离需要这些数据的组件最近的父组件来完成的。这就是所谓的状态提升。`this.props.xxx`
- 在`React`应用中，对应任何可变数据理应只有一个单一“数据源”。通常，状态都是首先添加在需要渲染数据的组件中。此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。

## 2.组件化以及组件数据流

### 2.1 `React`中的组件及数据流
- `React`是单向数据流，数据主要从父节点传递到子节点（通过`props`）。如果顶层（父级）的某个`props`改变了，`React`会重渲染所有的子节点。
- `React`中实现组件有两种实现方式，一种是createClass方法，另一种是通过ES2015的思想类继承`React`.Component来实现
- 在`React`应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件。
- `React`推崇的是函数式编程和单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）
- 组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。组件从概念上看就像是函数，它可以接收任意的输入值（称之为“`props`”），并返回一个需要在页面上展示的`React`元素。
 `1. props的只读性`
- 无论是使用函数或是类来声明一个组件，它决不能修改它自己的`props`。
- 所有的`React`组件必须像纯函数那样使用它们的`props`。

#### `props`与`state`的区别
- `props`是property的缩写，可以理解为`HTML`标签的attribute。不可以使用`this.props`直接修改`props`，因为`props`是只读的，`props`是用于整个组件树中传递数据和配置。在当前组件访问`props`，使用`this.props`。
- `props`是一个组件的设置参数，可以在父控件中选择性设置。父组件对子控件的`props`进行赋值，并且`props`的值不可改变。一个子控件自身不能改变自己的 `props`。
- `state`:当一个组件 mounts的时候，`state`如果设置有默认值的会被使用，并且`state`可能时刻的被改变。一个子控件自身可以管理自己的`state`，但是需要注意的是，无法管理其子控件的`state`。所以可以认为，`state`是子控件自身私有的。
- 每个组件都有属于自己的`state`，`state`和`props`的区别在于前者(`state`)只存在于组件内部，只能从当前组件调用`this.setState`修改`state`值（不可以直接修改`this.state`！）。
- `props`是一个父组件传递给子组件的数据流，可以一直的被传递到子孙组件中。然而 `state`代表的是子组件自身的内部状态。从语义上讲，改变组件的状态，可能会导致`DOM`结构的改变或者重新渲染。而`props`是父组件传递的参数，所以可以被用于初始化渲染和改变组件自身的状态，虽然大多数时候组件的状态是又外部事件触发改变的。我们需要知道的是，无论是`state`改变，还是父组件传递的 `props`改变，render方法都可能会被执行。
- 一般我们更新子组件都是通过改变`state`值，更新新子组件的`props`值从而达到更新。

#### 2.1.1 组件之间的通信
父子组件数通信
父与子之间通`props`属性进行传递
子与父之间，父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信
即：
- 父组件更新组件状态 —–`props`—–>　子组件更新
- 子组件更新父组件状态 —–需要父组件传递回调函数—–> 子组件调用触发

非父子组件之间的通信，嵌套不深的非父子组件可以使共同父组件，触发事件函数传形参的方式来实现
兄弟组件：
（1） 按照`React`单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的`props`。
- 其实这种实现方式与子组件更新父组件状态的方式是大同小异的。

（2） 当组件层次很深的时候，在这里，`React`官方给我们提供了一种上下文方式，可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。

#### 2.1.2 组件的生命周期
```javascript
construtor() //创建组件
componentWillMount() //组件挂载之前
componentDidMount() // 组件挂载之后
componentWillReceiveProps() // 父组件发生render的时候子组件调用该函数
shouldComponentUpdate() // 组件挂载之后每次调用setState后都会调用该函数判断是否需要重新渲染组件，默认返回true
componentDidUpdate() // 更新
render() //渲染，`React`中的核心函数
componentWillUnmount() //组件被卸载的时候调用，一般在componentDidMount注册的事件需要在这里删除
```
<img src="/static/img/3333422-04ea055c73c50c98.png" width="800" />

### 2.2 `Vue`中的组件和数据流

#### 2.2.1 组件化应用构建
- 组件系统是 `Vue` 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。
- 在 `Vue` 里，一个组件本质上是一个拥有预定义选项的一个 `Vue` 实例
- 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发可管理。
- 组件(component)是 `Vue` 最强大的功能之一。组件可以帮助你扩展基本的 `HTML` 元素，以封装可重用代码。在较高层面上，组件是 `Vue` 编译器附加行为后的自定义元素。在某些情况下，组件也可以是原生 `HTML` 元素的形式，以特定的 `is` 特性扩展。
- 组件中，data必须是一个函数
- 组件可以扩展 `HTML` 元素，封装可重用的代码。在较高层面上，组件是自定义元素，`Vue.js` 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 `HTML` 元素的形式，以 is 特性扩展。

#### 2.2.2 响应式
- 当一个 `Vue` 实例被创建时，它向 `Vue` 的响应式系统中加入了其 `data` 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。
- 当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时 `data` 中存在的属性是响应式的。

#### 2.2.3 组件的生命周期
- 每个 `Vue` 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 `DOM`、在数据变化时更新 `DOM` 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。
- 比如 `created` 钩子可以用来在一个实例被创建之后执行代码，也有一些其它的钩子，在实例生命周期的不同场景下调用，如 `mounted、updated、destroyed`。钩子的 `this` 指向调用它的 `Vue` 实例。
- 生命周期图示：
<img src="/static/img/lifecycle.png" width="600" />

#### 2.2.3 组件之间的通信
- `Vue`默认的是单向数据流，这是`Vue`直接提出来说明的，父组件默认可以向子组件传递数据，但是子组件向父组件传递数据就需要额外设置了。
- `Vue` 也支持双向绑定，默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让数据流易于理解。
- 父子组件之间的数据通信是通过`Prop`和自定义事件实现的，而非父子组件可以使用订阅/发布模式实现（类似于Angualr中的非父子指令之间的通信），再复杂一点也是建议使用状态管理（`Vuex`）。
- 在 `Vue` 中，父子组件之间的关系可以概述为：`props` 向下，`events` 向上。父组件通过 `props` 向下传递数据给子组件，子组件通过 `events` 发送消息给父组件。

##### 1.父向子
- 每个组件实例都有自己的孤立隔离作用域。也就是说，不能（也不应该）直接在子组件模板中引用父组件数据。要想在子组件模板中引用父组件数据，可以使用 `props` 将数据向下传递到子组件。
- 每个 `prop` 属性,都可以控制是否从父组件的自定义属性中接收数据。子组件需要使用 `props` 选项显式声明 `props`，以便它可以从父组件接收到期望的数据。
- 动态`props`，类似于将一个普通属性绑定到一个表达式，我们还可以使用 `v-bind` 将 `props` 属性动态地绑定到父组件中的数据。无论父组件何时更新数据，都可以将数据向下流入到子组件中

##### 2.子向父
- 使用自定义事件
- 每个 `Vue` 实例都接入了一个事件接口`(events interface)`，也就是说，这些 `Vue` 实例可以做到：
- 使用 `on(eventName)`监听一个事件−使用`emit(eventName)` 触发一个事件

##### 3. 非父子组件通信
- 可以使用一个空的 `Vue` 实例作为一个事件总线中心`(central event bus)`，用`emit`触发事件，`on`监听事件

#### 2.2.4 单向数据流
单向数据流示意图：
<img src="/static/img/flow.png" width="600" />

## 3.状态管理
### 3.1 `React`中的状态管理：`Flux`
- `Redux` 是 `React` 生态环境中最流行的 `Flux` 实现。`Redux` 事实上无法感知视图层，所以它能够轻松的通过一些简单绑定和 `Vue` 一起使用。

    1、创建`actions`

        1、定义动作，事件触发需要用`dispatcher`来调用
        2、行为，如增加操作、删除操作、更新操作，就是一堆函数。
    2、创建`store`

        1、`store`中包含应用的状态和逻辑，用来管理应用中不同的状态和逻辑，相当于`Model`层
    3、创建`dispatcher`

        1、在`dispatcher`中通过`register`来给每个`action`注对应的的`store`中的方法
    4、在`view`层调用`action`中的方法

        1、就是各类`component`

<img src="/static/img/20150625201409735.png" width="800" />

### 3.2 `Vue`中的状态管理`vuex`
- `Vuex`借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，`Vuex` 是专门为 `Vue.js` 设计的状态管理库，以利用 `Vue.js` 的细粒度数据响应机制来进行高效的状态更新。这使得它能够更好地和 Vue 进行整合，同时提供简洁的 API 和改善过的开发体验。
- 组件不允许直接修改属于 `store` 实例的 `state`，而应执行 action 来分发 (dispatch) 事件通知 `store` 去改变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录所有 `store` 中发生的 `state` 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。

- 每一个 `Vuex` 应用的核心就是 `store`（仓库）。“`store`”基本上就是一个容器，它包含着你的应用中大部分的状态

- `Vuex` 和单纯的全局对象有以下两点不同：

        1、`Vue`x 的状态存储是响应式的。当 `Vue` 组件从 `store` 中读取状态的时候，若 `store` 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

        2、你不能直接改变 `store` 中的状态。改变 `store` 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

        3、`state`

- `Vuex` 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 `store` 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。这也意味着，每个应用将仅仅包含一个 `store` 实例。

        1、Getters
- 从`state`中获取状态值，有时候我们需要从 `store` 中的 `state` 中派生出一些状态，例如对列表进行过滤并计数。

        1、Mutation
            1、更改 `Vuex` 的 `store` 中的状态的唯一方法是提交 mutation。`Vuex` 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 `state` 作为第一个参数。
            2、你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 `store.commit` 方法

        2、Action

            1、Action 类似于 mutation，不同在于：

            2、Action 提交的是 mutation，而不是直接变更状态。

            3、Action 可以包含任意异步操作。
            4、dispatch分发action

        3、Module

- 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，`store` 对象就有可能变得相当臃肿。
- `Vuex` 允许我们将 `store` 分割成模块（module）。每个模块拥有自己的 `state、mutation、action、getter`、甚至是嵌套子模块——从上至下进行同样方式的分割

<img src="/static/img/vuex (1).png" width="600" />

## 4.路由
- 两者的路由很相似，都是利用了组件化思想
### 4.1 `React`中的路由
- 在路由库的问题上，`React` 选择把问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，`React` 的生态系统相比 `Vue` 更加繁荣。
- `React`中，需要引入`react-router`库，
使用时，路由器Router就是`React`的一个组件。
- Router组件本身只是一个容器，真正的路由要通过Route组件定义。
- Route组件定义了URL路径与组件的对应关系。你可以同时使用多个Route组件。
```javascript
<Router history={hashHistory}>
  <Route path="/" component={App}/>
  <Route path="/repos" component={Repos}/>
  <Route path="/about" component={About}/>
</Router>
```
- Link组件用于取代元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是元素的`React` 版本，可以接收Router的状态。

### 4.2 `Vue`中的路由
- Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。
- 使用 `Vue.js` ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。

```html
<div id="app">
  <h1>Hello App!</h1>
  <p>
    <!-- 使用 router-link 组件来导航. -->
    <!-- 通过传入 `to` 属性指定链接. -->
    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
    <router-link to="/foo">Go to Foo</router-link>
    <router-link to="/bar">Go to Bar</router-link>
  </p>
  <!-- 路由出口 -->
  <!-- 路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>
```
## 5. 渲染性能对比
- 在操作界面时，要尽量减少对`DOM`的操作，`Vue` 和 `React` 都使用虚拟`DOM`来实现，并且两者工作一样好。
- 尽量减少除`DOM`操作以外的其他操作。（`Vue`和`React`的不同）

### 5.1 `React`视图渲染
- `React` 的渲染建立在 Virtual `DOM` 上——一种在内存中描述 `DOM` 树状态的数据结构。当状态发生变化时，`React` 重新渲染 Virtual `DOM`，比较计算之后给真实 `DOM` 打补丁。

- Virtual `DOM` 提供了函数式的方法描述视图，它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图与数据的同步。它也开辟了 JavaScript 同构应用的可能性。

- 在超大量数据的首屏渲染速度上，`React` 有一定优势，因为 `Vue` 的渲染机制启动时候要做的工作比较多，而且 `React` 支持服务端渲染。

- 元素是构成 `React` 应用的最小单位。元素用来描述你在屏幕上看到的内容，与浏览器的 `DOM` 元素不同，`React` 当中的元素事实上是普通的对象，`React` `DOM` 可以确保 浏览器 `DOM` 的数据内容与 `React` 元素保持一致。

- 我们用`React` 开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 `React` 的话，你可能会需要在不同的部分单独定义 `React` 根节点。我们将 元素传入一个名为 `ReactDOM.render()` 的方法来将其渲染到页面上，页面上就会显示该元素。

#### 组件渲染
- 当`React`遇到的元素是用户自定义的组件，它会将`JSX`属性作为单个对象传递给该组件,这个对象称之为“`props`”。

### 5.2 `Vue`视图渲染
- `Vue` 通过建立一个虚拟 `DOM` 对真实 `DOM` 发生的变化保持追踪。

- `Vue`渲染的过程如下：

    - `new Vue`，执行初始化
    - 挂载`$mount`方法，通过自定义`Render`方法、`template、el`等生成`Render`函数
    - 通过Watcher监听数据的变化
    - 当数据发生变化时，`Render`函数执行生成`VNode`对象
    - 通过`patch`方法，对比新旧`VNode`对象，通过`DOM Diff`算法，添加、修改、删除真正的`DOM`元素

## 小结
总结一下，我们发现，
### `Vue`的优势包括：
- 模板和渲染函数的弹性选择
- 简单的语法及项目创建
- 更快的渲染速度和更小的体积
### `React`的优势包括：
- 更适用于大型应用和更好的可测试性
- 同时适用于Web端和原生App
- 更大的生态圈带来的更多支持和工具

#### 而实际上，`React`和`Vue`都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：
- 利用虚拟`DOM`实现快速渲染
- 轻量级
- 响应式和组件化
- 服务器端渲染
- 易于集成路由工具，打包工具以及状态管理工具
- 优秀的支持和社区